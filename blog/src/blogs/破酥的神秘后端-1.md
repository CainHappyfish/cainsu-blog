---
title: "破酥的神秘后端-1"
date: "2025-12-23"
category: "后端"
tags: ["后端"]
summary: "可怜无助的前端er的后端学习之路..."
author: "破酥"
readTime: "5分钟"
cover: "https://pic1.imgdb.cn/item/694a4046b65a54c49ff012c6.png"
---

# 破酥的神秘后端-1

可怜无助的前端er的后端学习之路...

刚好毕设需要做前后端系统，这里就用nodejs + koa做一个比较粗糙的后端吧。本文大概是一个最简单的入门，了解一下后端的代码架构是怎么样的。

~~感谢 cursor 和 gpt 以及gemini 的大力支持~~

## 安装

确保你已经安装了 Node.js 和 npm（或 yarn）。然后，创建一个新的项目并安装 Koa。

```
mkdir koa-auth
cd koa-auth
npm init -y
npm install koa koa-router koa-bodyparser jsonwebtoken bcryptjs
```

你需要安装以下一些依赖：

- `koa`：Koa 框架本身。
- `koa-router`：用于路由管理。
- `koa-bodyparser`：解析请求体的中间件，处理 JSON 格式的请求。
- `jsonwebtoken`：用于生成和验证 JWT（Json Web Token）。
- `bcryptjs`：用于加密用户密码。

至于数据库，我直接用的 MySQL，网上安装教程一大堆，就不过多叙述了（好吧 Koa 的也是一大堆）

## 后端架构出门

在鹅的实习中我发现公司的项目结构似乎都是固定的，兴趣使然了解了一下，我个人（叠甲）将它分成：

- **表示层 (Presentation Layer)**：处理与用户的交互（请求和响应）。
- **应用层 (Application Layer)**：定义业务用例，协调服务层和领域层。
- **服务层 (Service Layer)**：实现具体的业务逻辑，协调不同领域模型。
- **领域层 (Domain Layer)**：封装核心业务逻辑和领域模型。
- **数据访问层 (DAO Layer)**：与数据库交互，处理数据持久化。
- **集成层 (Integration Layer)**：与外部系统或服务进行交互。
- **基础设施层 (Infrastructure Layer)**：提供支持性的通用服务，如日志、缓存等。

![](https://pic1.imgdb.cn/item/694a4475b65a54c49ff03fb6.png)

### **表示层 (Presentation Layer)**

表示层负责处理与用户的交互。它是用户请求和系统响应的入口，通常处理 HTTP 请求和响应。这一层不涉及业务逻辑，只负责展示数据和与用户的交互。具体功能：

- 接收来自客户端（如 Web 或移动端）的请求。
- 调用后续层来处理业务逻辑并返回响应。
- 数据展示和格式化，例如将数据转换为 JSON 或 HTML。

表示层常是 HTTP 请求处理框架（如 Express、Koa、Spring MVC）、模板引擎、前端框架。

### **应用层 (Application Layer)**

应用层用于定义系统的业务用例（Use Cases），是服务层和表示层的中介。它协调不同的服务层和领域层的操作，执行特定的业务功能（如用户注册、订单创建等）。具体功能：

- 调用领域层和服务层，组织具体的业务流程。
- 处理用户请求，执行业务场景。
- 负责异常处理、事务管理、应用流程控制。

在应用层中组织复杂的业务操作，例如在一个订单处理应用中，应用层会调用多个服务来完成订单的创建、支付等操作。那么接下来就是服务层了。

### **服务层 (Service Layer)**

服务层实现具体的业务逻辑。它与应用层紧密结合，负责处理复杂的业务规则，并调用领域层进行数据存取。服务层协调不同的领域模型和外部服务来实现应用需求。具体功能：

- 执行业务逻辑。
- 调用领域层的模型完成核心业务功能。
- 在服务层组织多个操作，确保业务流程的完整性。

### **领域层 (Domain Layer)**

领域层（也称为业务层）封装了应用的核心业务逻辑和规则，是系统的核心。领域层包括领域对象、实体、值对象、聚合根等，是核心业务模型所在的地方。具体功能：

- 实现业务领域模型和核心业务规则。
- 包含所有的领域对象和业务逻辑。
- 不依赖于其他层（如应用层或数据访问层），保持独立性。

**领域模型**：领域驱动设计（DDD）中定义的模型类，如实体、值对象、聚合根等。如电商系统中的 `Order` 类，它代表一个订单并包含订单相关的业务逻辑。

```ts
class Order {
  constructor(userId, products) {
    this.userId = userId;
    this.products = products;
    this.status = 'PENDING';
  }

  applyDiscount(discount) {
    this.products.forEach(product => {
      product.price -= product.price * discount;
    });
  }
}
```

### **数据访问层 (DAO Layer / Data Access Layer)**

数据访问层负责与数据库或其他持久化存储进行交互。它是对数据存储（如数据库）的抽象，提供持久化操作的接口，如增、删、查、改。具体功能：

- 提供对数据库的 CRUD 操作。
- 将领域对象转换为数据库存储格式。
- 实现具体的数据库查询和存储操作。

这里也简单介绍一下几个概念：

- **PO (Persistent Object)**：用于表示数据库中的持久化对象，通常与数据库表的结构一一对应。它是与数据库交互的实体类。

- **VO (Value Object)**：VO主要用于在不同层之间传递数据，关注数据的表示和传输。用于表示业务逻辑中的数据对象，通常用于封装一组相关属性，与特定的业务逻辑相关。

  具体来讲，VO主要用于在不同层之间传递数据，关注数据的表示和传输。在典型的软件架构中，不同层（如表示层、业务逻辑层、持久化层）可能需要使用不同的数据对象来完成其工作。VO可以在这些层之间传递数据，将数据从一个层传递到另一个层，同时封装了特定层次需要的数据格式。

- **DAO (Data Access Object)**：DAO是一个设计模式，用于封装数据访问逻辑，将数据访问与业务逻辑分离，表示用于对数据库进行访问的对象，负责执行与数据库相关的CRUD操作。~~哈哈，工业化 DAO 这一块~~

- **BO (Business Object)**：用于表示业务逻辑对象，封装了业务逻辑处理的代码。

- **DTO (Data Transfer Object)**：用于在不同层之间传输数据的对象，通常用于封装从数据库获取的数据或者传输数据给前端。

  > 为什么要有 DTO ？
  >
  > DTO（Data Transfer Object）是用于在不同层之间传递数据的对象，主要目的是解耦不同层次的依赖、提高安全性和控制权。它通过精简和定制数据，避免直接暴露复杂的领域模型或敏感信息，从而减少数据传输的开销，并确保前后端通信的一致性。DTO 还帮助简化与外部系统的交互，并提高系统的可扩展性和维护性，因为它允许灵活地修改数据结构而不影响系统的其他部分。

### **集成层 (Integration Layer)**

集成层用于与外部系统或服务进行集成，包括第三方 API 调用、消息队列、外部服务等。它负责与外部系统交互，通常不涉及业务逻辑。具体功能：

- 与外部系统（如支付网关、短信服务、邮件服务等）进行集成。
- 调用外部服务并处理返回的结果。
- 提供对外部资源的抽象和管理。

常见有 RESTful API、SOAP、消息队列、Webhooks 等等等。

### **基础设施层 (Infrastructure Layer)**

基础设施层负责提供系统的通用功能，如日志记录、缓存、消息队列、任务调度等。它支持其他层的运行，但不涉及业务逻辑。

## 登录 / 注册接口实现

我们就通过实现简单的登录/注册接口来具体说明各个分层的作用。

在 Koa 中我们可以通过控制器层（Controller）将接收请求并将其转发到业务逻辑层，这就是表示层的作用，用于将请求转发到我们的登录/注册服务去：

```ts
const router = new Router({ prefix: '/auth' })

/**
 * 登录
 * POST /api/auth/login
 */
router.post('/login', AuthController.login)

/**
 * 注册
 * POST /api/auth/register
 */
router.post('/register', AuthController.register)

```

当收到登录/注册的请求后，我们需要将其转发到对应的控制层，由控制层调用对应的服务，参考经典的 OOP 思想，我们封装成一个类：

``` ts
export class AuthController {
  /**
   * 登录
   */
  static async login(ctx: Context): Promise<void> {}

  /**
   * 注册
   */
  static async register(ctx: Context): Promise<void> {}

  /**
   * 验证 Token
   */
  static async verifyToken(ctx: Context): Promise<void> {}

  /**
   * 刷新 Token
   */
  static async refreshToken(ctx: Context): Promise<void> {}
}
```

> 对于这个 `AuthController`，因为你要实现登录、注册、验证 Token 等功能，这些方法通常是独立的，并且不需要访问类的实例变量，所以**使用 `static`** 是更合适的。

那么我们通过路由调用这个`AuthController`的不同方法时，就会将请求转发到服务层中对应的服务去进行进一步的业务逻辑处理。这里就拿登录接口来说事，我是这样实现控制层的：

```ts
  /**
   * 登录
   */
  static async login(ctx: Context): Promise<void> {
    try {
      const { username, password } = ctx.request.body as Record<string, unknown>

      Logger.business('AuthController', 'Login request', { username })

      const result = await AuthService.login({
        username: username as string,
        password: password as string,
      })

      Logger.business('AuthController', 'Login success', { userId: result.user.id })
      success(ctx, result, SUCCESS_MESSAGES.LOGIN_SUCCESS)
    } catch (err) {
      const appError = err instanceof AppError ? err : (err as Error)
      const errorCode =
        appError instanceof AppError ? appError.httpStatus : HTTP_STATUS.INTERNAL_ERROR
      const errorMessage = appError.message || 'Internal server error'
      Logger.business('AuthController', 'Login failed', {
        error: errorMessage,
        code: errorCode,
      })
      error(ctx, errorCode, errorMessage)
    }
  }
```

结构也很简单，加入了日志系统方便调试和日后上线时的上报，而后就是调用具体的` AuthService`，以及处理登录时可能的错误。这里我的习惯是在 http 错误码的基础上有一套自己的错误码，方便确定错误原因。那么接下来我们看服务层登录服务的具体实现：

``` ts
  /**
   * 登录
   */
  static async login(credentials: LoginRequest): Promise<LoginResponse> {
    Logger.auth('Login attempt', undefined, { username: credentials.username })

    // 验证输入
    if (!credentials.username || !credentials.password) {
      Logger.warn('Login failed: missing credentials', { username: credentials.username })
      throw new ValidationError(ERROR_CODES.MISSING_REQUIRED_FIELDS)
    }

    // 查找用户
    const user = await UserModel.findByUsername(credentials.username)
    if (!user) {
      Logger.warn('Login failed: user not found', { username: credentials.username })
      throw new AuthError(ERROR_CODES.INVALID_CREDENTIALS)
    }

    // 验证密码
    if (!user.password) {
      Logger.warn('Login failed: user password not set', { username: credentials.username })
      throw new AuthError(ERROR_CODES.PASSWORD_NOT_SET)
    }

    const isPasswordValid = await bcrypt.compare(credentials.password, user.password)
    if (!isPasswordValid) {
      Logger.warn('Login failed: invalid password', { username: credentials.username })
      throw new AuthError(ERROR_CODES.INVALID_CREDENTIALS)
    }

    // 生成 JWT token
    const payload: AuthTokenPayload = {
      id: user.id,
      username: user.username,
      email: user.email,
    }

    const token = jwt.sign(payload, AUTH_CONFIG.JWT_SECRET, {
      expiresIn: AUTH_CONFIG.JWT_EXPIRY,
    })

    Logger.auth('Login success', user.id, { username: user.username })

    // 更新最后登录时间
    await UserModel.updateLastLogin(user.id)

    return {
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
      },
    }
  }
```

我们调用领域驱动设计（DDD）中定义的模型类，用来操作访问数据库中的用户数据，而不是直接操作数据库，这样将业务逻辑和数据库操作解耦，不仅可以改善系统的结构，也能让业务逻辑更加清晰、可扩展、可维护。这里还涉及到一个知识点 JWT，在后面会进行具体的说明。我们来看具体的模型是如何设计的：

```ts
/**
 * 用户模型类
 * 作为业务层和数据访问层之间的适配器
 */
export class UserModel {
  /**
   * 根据 ID 查找用户
   */
  static async findById(id: string): Promise<User | null> {
    return await userDAO.findById(id)
  }

  /**
   * 根据用户名查找用户
   */
  static async findByUsername(username: string): Promise<User | null> {
    return await userDAO.findByUsername(username)
  }

  /**
   * 根据邮箱查找用户
   */
  static async findByEmail(email: string): Promise<User | null> {
    return await userDAO.findByEmail(email)
  }

  /**
   * 获取所有用户（支持分页）
   */
  static async findAll(skip?: number, limit?: number): Promise<User[]> {
    return await userDAO.findAll(skip, limit)
  }

  /**
   * 创建用户
   */
  static async create(userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>): Promise<User> {
    return await userDAO.create({
      username: userData.username,
      email: userData.email,
      password: userData.password || '',
      isActive: userData.isActive,
    })
  }

  /**
   * 更新用户
   */
  static async update(id: string, updateData: Partial<User>): Promise<User> {
    return await userDAO.update(id, {
      username: updateData.username,
      email: updateData.email,
      password: updateData.password,
      isActive: updateData.isActive,
      lastLoginAt: updateData.lastLoginAt,
    })
  }

  /**
   * 删除用户
   */
  static async delete(id: string): Promise<boolean> {
    return await userDAO.delete(id)
  }

  /**
   * 获取用户总数
   */
  static async count(): Promise<number> {
    return await userDAO.count()
  }

  /**
   * 更新最后登录时间
   */
  static async updateLastLogin(id: string): Promise<void> {
    return await userDAO.updateLastLogin(id)
  }
}

```

不难发现领域层就是通过调用 DAO 获取、操作和对数据进行处理的。数据层就没什么好说的了，就是操作数据库用的。为了更好地规范数据库操作行为，我们可以先定义一个 BaseDAO 类进行约束，其余业务 DAO 均为该类的子类：

```ts
/**
 * 基础DAO接口和实现
 */

import type { PoolConnection } from 'mysql2/promise'
import { query, queryOne, execute, beginTransaction, commit, rollback } from '../utils/database'

/**
 * 基础DAO接口
 */
export interface IBaseDAO<T, CreateInput, UpdateInput> {
  /**
   * 根据ID查找
   */
  findById(id: string): Promise<T | null>

  /**
   * 查找所有记录（支持分页）
   */
  findAll(skip?: number, limit?: number): Promise<T[]>

  /**
   * 创建记录
   */
  create(data: CreateInput): Promise<T>

  /**
   * 更新记录
   */
  update(id: string, data: UpdateInput): Promise<T>

  /**
   * 删除记录
   */
  delete(id: string): Promise<boolean>

  /**
   * 统计记录数
   */
  count(): Promise<number>
}

/**
 * 基础DAO抽象类
 */
export abstract class BaseDAO<T, CreateInput, UpdateInput> implements IBaseDAO<
  T,
  CreateInput,
  UpdateInput
> {
  protected abstract tableName: string
  protected abstract primaryKey: string

  /**
   * 将数据库行转换为实体对象
   */
  protected abstract rowToEntity(row: any): T

  /**
   * 将实体对象转换为数据库行
   */
  protected abstract entityToRow(entity: Partial<T>): any

  /**
   * 根据ID查找
   */
  async findById(id: string): Promise<T | null> {
    const sql = `SELECT * FROM ${this.tableName} WHERE ${this.primaryKey} = ?`
    const row = await queryOne(sql, [id])
    return row ? this.rowToEntity(row) : null
  }

  /**
   * 查找所有记录（支持分页）
   */
  async findAll(skip?: number, limit?: number): Promise<T[]> {
    let sql = `SELECT * FROM ${this.tableName} ORDER BY created_at DESC`
    const params: any[] = []

    if (limit !== undefined) {
      sql += ' LIMIT ?'
      params.push(limit)
      if (skip !== undefined) {
        sql += ' OFFSET ?'
        params.push(skip)
      }
    }

    const rows = await query(sql, params)
    return rows.map(row => this.rowToEntity(row))
  }

  /**
   * 创建记录
   */
  async create(data: CreateInput): Promise<T> {
    const row = this.entityToRow(data as Partial<T>)
    const fields = Object.keys(row)
    const values = Object.values(row)
    const placeholders = fields.map(() => '?').join(', ')

    const sql = `INSERT INTO ${this.tableName} (${fields.join(', ')}) VALUES (${placeholders})`
    const result = await execute(sql, values)

    // 获取插入的ID（如果是自增ID）
    const insertedId = (result as any).insertId || row[this.primaryKey]
    const entity = await this.findById(insertedId)
    if (!entity) {
      throw new Error(`Failed to create ${this.tableName}`)
    }
    return entity
  }

  /**
   * 更新记录
   */
  async update(id: string, data: UpdateInput): Promise<T> {
    const row = this.entityToRow(data as Partial<T>)
    const fields = Object.keys(row).filter(key => key !== this.primaryKey)
    const values = Object.values(row).filter(
      (_, index) => Object.keys(row)[index] !== this.primaryKey
    )

    if (fields.length === 0) {
      const entity = await this.findById(id)
      if (!entity) {
        throw new Error(`${this.tableName} not found`)
      }
      return entity
    }

    const setClause = fields.map(field => `${field} = ?`).join(', ')
    const sql = `UPDATE ${this.tableName} SET ${setClause} WHERE ${this.primaryKey} = ?`
    await execute(sql, [...values, id])

    const entity = await this.findById(id)
    if (!entity) {
      throw new Error(`${this.tableName} not found after update`)
    }
    return entity
  }

  /**
   * 删除记录
   */
  async delete(id: string): Promise<boolean> {
    const sql = `DELETE FROM ${this.tableName} WHERE ${this.primaryKey} = ?`
    const result = await execute(sql, [id])
    return result.affectedRows > 0
  }

  /**
   * 统计记录数
   */
  async count(): Promise<number> {
    const sql = `SELECT COUNT(*) as total FROM ${this.tableName}`
    const row = await queryOne<{ total: number }>(sql)
    return row?.total || 0
  }

  /**
   * 开始事务
   */
  async beginTransaction(): Promise<PoolConnection> {
    return await beginTransaction()
  }

  /**
   * 提交事务
   */
  async commitTransaction(connection: PoolConnection): Promise<void> {
    await commit(connection)
  }

  /**
   * 回滚事务
   */
  async rollbackTransaction(connection: PoolConnection): Promise<void> {
    await rollback(connection)
  }

  /**
   * 执行自定义查询
   */
  protected async query<T = any>(sql: string, params?: any[]): Promise<T[]> {
    return await query<T>(sql, params)
  }

  /**
   * 执行自定义单条查询
   */
  protected async queryOne<T = any>(sql: string, params?: any[]): Promise<T | null> {
    return await queryOne<T>(sql, params)
  }

  /**
   * 执行自定义更新/插入/删除
   */
  protected async execute(sql: string, params?: any[]): Promise<any> {
    return await execute(sql, params)
  }
}

```

这里用抽象类的目的就很明显了，为了规范子类。

> Tips：TS 中抽象类和接口的区别和联系
>
> 在 TypeScript 中，抽象类（abstract class）和接口（interface）是两种用于定义类型和约束的结构。
>
> ### **抽象类（abstract class）**
>
> - 抽象类是不能被直接实例化的类，它主要用于为派生类提供一个基础的实现框架。抽象类可以包含具体实现（即方法有方法体）和抽象方法（即没有方法体，需要由子类实现）。
> - 抽象类可以包含字段、构造函数和方法，也可以定义访问修饰符（如 `public`, `private`）。
>
> #### 特点：
>
> - **可以包含实现**：抽象类可以提供一些方法的实现，子类可以直接使用或重写这些方法。
> - **可以包含字段**：抽象类可以定义字段，子类可以继承这些字段。
> - **只能被继承**：抽象类不能直接实例化，必须通过继承来创建实例。
> - **支持访问修饰符**：方法和属性可以使用 `public`, `private`, `protected` 等修饰符。
>
> ```
> abstract class Animal {
>   constructor(public name: string) {}
> 
>   // 抽象方法，没有方法体，必须由子类实现
>   abstract makeSound(): void;
> 
>   // 具体方法，有方法体，子类可以直接使用或重写
>   sleep() {
>     console.log(`${this.name} is sleeping.`);
>   }
> }
> 
> class Dog extends Animal {
>   makeSound() {
>     console.log("Woof!");
>   }
> }
> 
> const dog = new Dog("Buddy");
> dog.makeSound(); // Woof!
> dog.sleep(); // Buddy is sleeping.
> ```
>
> ### **接口（interface）**
>
> - 接口是一种更轻量的结构，它用于定义对象的形状（即约定对象的属性和方法），不涉及实现细节。接口无法包含方法实现，只能声明方法和属性的签名。
> - 一个类可以实现一个或多个接口，接口可以继承其他接口。
>
> #### 特点：
>
> - **只能声明方法签名**：接口只能定义方法的名称、参数类型和返回类型，不能提供方法的实现。
> - **不能包含字段的实现**：接口只能声明字段，但不能提供字段的实际值或实现。
> - **可以多继承**：接口可以通过 `extends` 继承多个接口，从而获得多个接口的类型约束。
> - **可以被类实现**：类通过 `implements` 关键字来实现接口。
>
> ```
> interface Animal {
>   name: string;
>   makeSound(): void;
> }
> 
> class Dog implements Animal {
>   constructor(public name: string) {}
> 
>   makeSound() {
>     console.log("Woof!");
>   }
> }
> 
> const dog = new Dog("Buddy");
> dog.makeSound(); // Woof!
> ```
>
> ### 区别
>
> | 特性           | **抽象类（abstract class）**                             | **接口（interface）**                          |
> | -------------- | -------------------------------------------------------- | ---------------------------------------------- |
> | **实现方式**   | 可以包含方法的实现（具体实现和抽象方法）。               | 只能声明方法和属性，不能包含实现。             |
> | **构造函数**   | 可以有构造函数，用于子类实例化时初始化字段。             | 不可以有构造函数。                             |
> | **字段**       | 可以包含字段，并且可以提供默认实现。                     | 只能声明字段，不能提供字段的值或实现。         |
> | **继承/实现**  | 类只能继承一个抽象类。                                   | 类可以实现多个接口，接口也可以继承多个接口。   |
> | **访问修饰符** | 可以使用 `public`, `protected`, `private` 等访问修饰符。 | 只能定义公有的属性和方法，不能指定访问修饰符。 |
> | **实例化**     | 抽象类不能实例化，只能通过子类来实例化。                 | 接口不能实例化，只能通过类实现。               |
> | **用途**       | 用于实现类的基础功能和提供默认实现。                     | 用于定义对象的形状或行为规范，强调类型约束。   |
>
> ### **联系**
>
> - **都用于约束类型**：抽象类和接口都用于定义类型，它们的目的是让类实现某些功能或行为的规范。
> - **都可以被类继承或实现**：类可以继承抽象类，也可以实现接口。两者都可以用于强制子类或实现者遵守某些结构和行为。
> - **都支持多态性**：通过继承抽象类或实现接口，子类或实现类可以根据需要重写方法，并具备多态性。
> - **接口可以继承抽象类**：虽然接口不能提供方法实现，但接口可以继承抽象类，这样它可以约束抽象类的字段和方法，并要求实现类提供具体的实现。
>
> ### **选择使用抽象类还是接口**
>
> - **使用抽象类**：
>   - 当你需要共享一些方法实现或字段时，使用抽象类。它可以包含具体实现并提供字段。
>   - 当你希望某些方法必须在子类中实现时，使用抽象类。
>   - 当你需要控制类的继承（即只能继承一个类）时，使用抽象类。
> - **使用接口**：
>   - 当你希望定义某种行为的规范，而不关心具体实现时，使用接口。
>   - 当你需要支持多重继承或多实现时，使用接口。
>   - 当你不希望类继承不必要的实现时，使用接口。
>
> ### 总结
>
> - **抽象类**适用于需要共享代码和实现的一部分功能，同时可以提供默认实现和字段。它更加强调类的继承和复用。
> - **接口**适用于定义一组行为的规范，不涉及具体的实现。它更适合用于定义类型约束，强调多重实现和解耦。
>
> 两者可以结合使用，抽象类提供默认实现，接口定义行为规范，这样可以获得更高的灵活性和可维护性。那么这里用抽象类的目的就很明显了，为了规范子类

我们继续看` UserDAO `的具体实现，无非就是在` BaseDAO `的约束下根据具体登录/注册等业务逻辑实现数据的 crud 罢了，这里就不贴代码浪费篇幅。这样我们就顺着数据流动的方向完成了登录/注册接口

## JWT

> 常考八股...

JWT（JSON Web Token）是一种用于**身份认证**和**信息交换**的开放标准（RFC 7519）。它通过 JSON 格式安全地传输信息，通常用于 Web 应用中传递用户认证信息和授权信息。JWT 的特点是轻量级、跨平台、易于传输和解析，因此被广泛应用于分布式系统中，尤其是在单点登录（SSO）和 API 认证等场景中。

### JWT 的基本结构

一个典型的 JWT 由 **三个部分**组成：

- **头部（Header）**
- **有效载荷（Payload）**
- **签名（Signature）**

这三部分通过点 (`.`) 连接在一起，形成一个字符串：`header.payload.signature`。接下来我们详细介绍 jwt 的组成部分和具体工作原理，以及为什么要使用 JWT 。

#### **头部（Header）**

头部通常包含两部分信息：

- **签名算法**：常见的算法有 HMAC SHA256 和 RSA。
- **类型**：标明 token 的类型，通常是 `JWT`。

```
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- **`alg`**：表示签名使用的算法，例如 HMAC SHA256 或 RSA。
- **`typ`**：通常固定为 `JWT`，表示这就是一个 JWT。

#### **有效载荷（Payload）**

有效载荷包含**声明（Claims）**，声明是对某些实体（通常是用户）及其元数据的描述。声明有三种类型：

- **注册声明（Registered Claims）**：这些是预定义的声明，可以提供有关 JWT 的标准信息。例如：
  - **`iss`**（Issuer）：发行者
  - **`sub`**（Subject）：主题
  - **`aud`**（Audience）：受众
  - **`exp`**（Expiration Time）：过期时间
  - **`iat`**（Issued At）：签发时间
  - **`nbf`**（Not Before）：生效时间
  - **`jti`**（JWT ID）：JWT 的唯一标识符
- **公共声明（Public Claims）**：这些声明可以自定义，但为了避免冲突，最好使用 URI（如 `example.com`）作为命名空间。
- **私有声明（Private Claims）**：这些是双方应用之间约定的声明，通常用于在系统之间传递非公开信息。

**示例**：

```
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```

#### **签名（Signature）**

为了防止数据被篡改，我们使用头部指定的签名算法（如 HMAC SHA256）对头部和有效载荷进行签名。签名是通过以下步骤生成的：

- 将编码后的头部和有效载荷用 `.` 拼接起来。
- 使用指定的签名算法对拼接后的字符串进行加密，使用密钥（对于 HMAC）或私钥（对于 RSA）进行加密。

**示例**：

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

签名的作用是：

- **验证消息的完整性**：确保消息在传输过程中没有被篡改。
- **验证消息的来源**：确认消息是由声称的发送方发出的。

### 工作流程

#### 1. **用户登录并获取 JWT**

- 用户提交用户名和密码进行登录。
- 服务器验证用户凭证。如果验证通过，服务器生成一个 JWT，其中包含用户的身份信息（如用户 ID）和其他信息（如权限等）。
- 服务器将生成的 JWT 返回给客户端，客户端通常将其存储在浏览器的 **localStorage** 或 **sessionStorage** 中。

#### 2. **客户端发送请求**

- 当客户端向服务器发送请求时（例如调用 API），客户端会在 HTTP 请求头中附加 JWT，通常使用 `Authorization` 字段，格式为 `Bearer <JWT>`。

  **请求示例**：

  ```
  GET /api/protected
  Authorization: Bearer <JWT>
  ```

#### 3. **服务器验证 JWT**

- 服务器从请求头中提取 JWT，并对其进行验证：
  - **验证签名**：确保数据没有被篡改。
  - **验证过期时间**：如果 JWT 超过了 `exp` 声明的过期时间，则认为它无效。
  - **验证其他声明**（如 `iss`、`aud` 等）是否符合预期。

#### 4. **授权访问**

- 如果 JWT 验证成功，服务器允许访问受保护的资源；如果验证失败，服务器返回 401 Unauthorized 错误。

### JWT 的优缺点

优点：

1. **无状态（Stateless）**：JWT 使得服务器不需要存储会话信息，减少了服务器的存储压力。每个请求都包含所有需要的认证信息。
2. **跨域支持**：JWT 通过 HTTP 请求头发送，不依赖于浏览器的 cookie，因此特别适合跨域应用。
3. **灵活性**：JWT 可以承载任意数据，且可以通过自定义声明（Claims）来传递更多的信息。
4. **便于集成**：JWT 是标准化的，易于与不同平台和技术栈集成。

好处说完了，坏处呢？缺点：

1. **安全性问题**：如果密钥泄露，JWT 就不再安全，因此需要确保密钥管理的安全。
2. **无法撤销**：JWT 通常有有效期，一旦生成后，不能撤销，除非进行额外的管理（如维护黑名单）。这可能导致在用户登出或密钥更换时需要特别处理。
3. **较大的负载**：因为 JWT 包含了所有的数据（包括用户信息等），因此它可能比传统的 Session Cookie 更大，这会影响带宽和性能，尤其是在高频请求的场景下。

