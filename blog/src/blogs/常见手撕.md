---
title: "前端常见手撕"
date: "2025-09-11"
category: "八股"
tags: ["八股", "j手撕"]
summary: "前端常见手撕，面试用"
author: "破酥"
readTime: "60分钟"
---

# 前端常见手撕

前端常见手撕，面试用

# `Promise.all`

`promise.all` 的规则是这样的：

- 传入的所有 Promise 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；
- 只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；
- 只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；

```typescript
Promise.myAll = function(arr) {
	let index = 0, result = []
	return new Promise((res, rej) => {
		arr.forEach((p, i) => {
			Promise.resolve(p)
			.then(val => {
				index++
				result[i] = val
				if (index === arr.length) {
					res(result)
				}
			**})
			.catch(err => {
				rej(err)
			})**
		})
	})
}
```

# `Promise.race`

`Promise.race` 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。

```typescript
Promise.myRace = function(arr) {
	return new Promise((res, rej) => {
		arr.forEach((p, i) => {
			Promise.resolve(p)
			.then(val => {
				resolve(result)
			**})
			.catch(err => {
				reject(err)
			})**
		})
	})
}
```

# **`Promise.allSettled`**

Promise.allSettled 的规则是这样：

- 所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象；
- 如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例；

```typescript
Promise.myAllSettled = function(arr) {
	let result = []
	return new Promise((res, rej) => {
		arr.forEach((p, i) => {
			Promise.resolve(p)
			.then(val => {
				result.push({
          status: 'fulfilled',
          value: val
        })
				if (result.length === arr.length) {
					resolve(result)
				}
			})
			.catch(err => {
				result.push({
          status: 'rejected',
          reason: err
        })
				if (result.length === arr.length) {
					resolve(result)
				}
			})
		})
	})
}
```

# **`Promise.any`**

Promise.any 的规则是这样：

- 空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；
- 只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；
- 其他情况都会返回一个 pending 的新实例；

```typescript
Promise.myAny = function(arr) {
	let index = 0
	return new Promise((res, rej) => {
		arr.forEach((p, i) => {
			Promise.resolve(p)
			.then(val => {
				resolve(result)
			})
			.catch(err => {
				index++
        if (index === promiseArr.length) {
          reject(new AggregateError('All promises were rejected'))
        }
			})
		})
	})
}
```

# 并发控制

```javascript
class AsyncPool {
  constructor(max, fn, urls) {
    this.max = max
    this.fn = fn
    this.asyncPool = []
    this.urls = urls
  }

  start() {
    // 填满并发池
    while (this.asyncPool.length < this.max) {
      const url = this.urls.shift()
      this.setPromise(url)
    }

    this.run(Promise.race(this.asyncPool))
  }

  setPromise(url) {
    if (!url) return;
    const promise = this.fn(url)
    this.asyncPool.push(promise)
    console.log(`${url}开始执行，当前并发数${this.asyncPool.length}`)
    promise.finally(() => {
      // 请求结束时移除并发池
      const index = this.asyncPool.indexOf(promise)
      this.asyncPool.splice(index, 1)
      console.log(`${url}执行结束，当前并发数${this.asyncPool.length}`)
    })
  }

  run(race) {
    race.then(() => {
      const url = this.urls.shift()
      this.setPromise(url)
      this.run(Promise.race(this.asyncPool))
    })
  }

}

const URLs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
// 模拟异步请求函数
let fn = (url) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`任务${url}完成`);
    }, 2000);
  }).then((res) => {
    console.log(res);
  });
};
// 并发数为3
const Arr = new AsyncPool(3, fn, URLs);
Arr.start(URLs);

```

# 数组方法

## **手写forEach**

```javascript
let family = ['jim', 'tom', 'jack', 'kim']
Array.prototype.myforEach= function(func) {
  if (this === null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof func !== 'function') {
      throw new TypeError(func + ' is not a function');
  }
  let arr = this;
  for (let i = 0; i < arr.length; i++) {
	  // 执行
    func(arr[i], i, arr)
  }
}
family.forEach((item, index, arr) => {arr[index] = `hello ${item}`}) // ["hello jim", "hello tom", "hello jack", "hello kim"]
family.myforEach((item, index, arr) => {arr[index] = `${item}!`})    // ["hello jim!", "hello tom!", "hello jack!", "hello kim!"]
```

## **手写map**

```javascript
let family = ['jim', 'tom', 'jack', 'kim']
Array.prototype.myMap= function(func) {
  if (this === null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof func !== 'function') {
      throw new TypeError(func + ' is not a function');
  }
  let arr = this;
  console.log(arr)
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
	  // 将执行结果存入数组并返回
    newArr.push(func(arr[i], i, arr))
  }
  return newArr;
}
let  arr1 = family.map((item, index, arr) => {return `hello ${item}`})  // ["hello jim", "hello tom", "hello jack", "hello kim"]
let  arr2 = family.myMap((item, index, arr) => {return `hello ${item}`})  // ["hello jim", "hello tom", "hello jack", "hello kim"]
```

## **手写 filter**

```javascript
let family = ['jim', 'tom', 'jack', 'kim']
Array.prototype.myFilter= function(func) {
  if (this === null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof func !== 'function') {
      throw new TypeError(func + ' is not a function');
  }
  let arr = this;
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
	  // 判断是否满足条件，将满足的对应元素加入结果数组中并返回
    if (func(arr[i], i, arr)) {
      newArr.push(arr[i])
    }
  }
  return newArr;
}
let arr1 = family.filter((item, index, arr) => { return index !== 2}) // ['jim', 'tom', 'kim']
let arr2 = family.myFilter((item, index, arr) => { return index !== 2}) // ['jim', 'tom', 'kim']
```

## **手写 some/every**

```javascript
let family = ['jim', 'tom', 'jack', 'kim']
Array.prototype.mySome= function(func) {
  if (this === null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof func !== 'function') {
      throw new TypeError(func + ' is not a function');
  }
  let arr = this;
  for (let i = 0; i < arr.length; i++) {
	  // 有一个满足条件就返回 true
    if (func(arr[i], i, arr)) {
      return true
    }
  }
  return false;
}
family.some((item, index, arr) => { return item === 'bim'}) // true
family.mySome((item, index, arr) => { return item === 'bim'}) // true
// every
Array.prototype.myEvery= function(func) {
  if (this === null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof func !== 'function') {
      throw new TypeError(func + ' is not a function');
  }
  let arr = this;
  for (let i = 0; i < arr.length; i++) {
	  // 有一个不满足条件就返回 false
    if (!func(arr[i], i, arr)) {
      return false;
    }
  }
  // 全部满足条件才返回 true
  return true;
}
family.every((item, index, arr) => { return item === 'bim'}) // false
family.myEvery((item, index, arr) => { return item === 'bim'}) // false
```

## **手写find**

```javascript
let family = ['jim', 'tom', 'jack', 'kim']
Array.prototype.myFind= function(func) {
  if (this === null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof func !== 'function') {
      throw new TypeError(func + ' is not a function');
  }
  let arr = this;
  for (let i = 0; i < arr.length; i++) {
    if (func(arr[i], i, arr)) {
      return arr[i]
    }
  }
  return undefined;
}
let name1 = family.find((item, index, arr) => { return item === 'kim'}) // kim
let name2 = family.myFind((item, index, arr) => { return item === 'kim'})  // kim
// findIndex
Array.prototype.myFindIndex= function(func) {
  if (this === null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof func !== 'function') {
      throw new TypeError(func + ' is not a function');
  }
  let arr = this;
  for (let i = 0; i < arr.length; i++) {
    if (func(arr[i], i, arr)) {
      return i
    }
  }
  return -1;
}
let num1 = family.findIndex((item, index, arr) => { return item === 'kim'}) // 3
let num2 = family.myFindIndex((item, index, arr) => { return item === 'kim'})  // 3
```

## 手写 reduce

`reduce()` 和 `reduceRight()` 是用于将数组元素累积成单一值的高阶函数。它们的主要区别在于遍历数组的方向不同：

- **`reduce()`**：从左到右遍历数组。
- **`reduceRight()`**：从右到左遍历数组。

```javascript
array.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue);
array.reduceRight(callback(accumulator, currentValue, currentIndex, array), initialValue);
```

- **`callback`**：在每次迭代中执行的函数，接收四个参数：
    - `accumulator`：累积器，存储上次迭代的返回值，或者是 `initialValue`。
    - `currentValue`：当前元素的值。
    - `currentIndex`：当前元素的索引。
    - `array`：调用 `reduce` 或 `reduceRight` 的数组。
- **`initialValue`**：可选，指定累积器的初始值。如果省略，`accumulator` 将是数组的第一个元素，`currentValue` 从第二个元素开始。

```javascript
let family = ['jim', 'tom', 'jack', 'kim']
Array.prototype.myReduce = function(func, initialValue) {
  if (this === null) {
    throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof func !== 'function') {
    throw new TypeError(func + ' is not a function');
  }
  let arr = this;
  let prev = initialValue !== undefined ? initialValue : arr[0];
  let len = initialValue !== undefined ? arr.length : arr.length - 1;
  for (let i = 0; i < len; i++) {
    let cur = initialValue !== undefined ? arr[i] : arr[i + 1];
    prev = func(prev, cur, i, arr);
  }
  return prev;
};

let arr1 = family.reduce((prev, cur, index, arr) => { return `${prev}-${cur}`}) // jim-tom-jack-kim
let arr2 = family.myReduce((prev, cur, index, arr) => { return `${prev}-${cur}`}) // jim-tom-jack-kim

// reduceRight
Array.prototype.myReduceRight = function(func, initialValue) {
  if (this === null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof func !== 'function') {
      throw new TypeError(func + ' is not a function');
  }
  let arr = this;
  let prev = initialValue || arr[arr.length - 1]
  let num = initialValue ? -1 : 0
  for (let i = arr.length - 1; i > num; i--) {
    let cur = initialValue ? arr[i] : arr[i - 1]
    prev = func(prev, cur, i, arr)
  }
  return prev;
}
let arr3 = family.reduce((prev, cur, index, arr) => { return `${prev}-${cur}`}) // kim-jack-tom-jim
let arr4 = family.myReduce((prev, cur, index, arr) => { return `${prev}-${cur}`}) // kim-jack-tom-jim
```

## `Array.from`

```javascript
Array.myFrom = function (el) {
  return Array.apply(this, el);
}
var arrLike = {length: 4, 2: "foo" };
var arr = Array.from( arrLike ); //  [undefined, undefined, "foo", undefined]
```

# **用 reduce 实现 map 方法**

```javascript
Array.prototype.myMap = function(callback, thisArg) {
  return this.reduce((acc, currentValue, index, array) => {
    const result = callback.call(thisArg, currentValue, index, array)
    return acc.concat([result])// 使用concat而不是push，支持更好的函数式编程
  }, [])
}

// 链式调用示例
const result = [1, 2, 3]
  .myMap(x => x * 2)
  .myMap(x => x + 1)
  .myMap(x => `数字: ${x}`)

console.log(result)// ["数字: 3", "数字: 5", "数字: 7"]
```

# 手写 call

使用一个指定的 this 值和一个或多个参数来调用一个函数。

```typescript
Function.prototype.myCall = function(context) {
    if (typeof this !== 'function') {
        throw Error('Error Type')
    }

    context = context || window
    // context = context || global
    context.fn = this
    const args = [...arguments].slice(1)
    const result = context.fn(...args)
    delete context.fn
    return result
}

var color = 'blue'
let colors = {
  color: 'red'
}

function box(width, height) {
  console.log(width)
  console.log(height)
  console.log(this.color)
}

box.myCall(colors, 200, 300)   // 200, 300, red
// node 环境输出 undefined
box.myCall(null, 200, 300)     // 200, 300, blue

```

> 为什么 box.myCall(null, 200, 300) 在浏览器环境下输出200, 300, blue，在node下输出200, 300, undefined ？
Node.js 默认在模块作用域内启用了严格模式
> 

# 手写 apply

apply 和 call 一样，唯一的区别就是 call 是传入不固定个数的参数，而 apply 是传入一个数组。

```typescript
Function.prototype.myApply = function (context, arr) {
  if (typeof this !== 'function') {
      throw Error('Error Type')
  }
  
  context = context || window
  context.fn = this
  
  let result 
  if (!arr) {
    result = context.fn()
  } else {
    result = context.fn(...arr)
  }
  delete context.fn
  return result
}

var color = 'blue'
let colors = {
  color: 'red'
}

function box(width, height) {
  console.log(width)
  console.log(height)
  console.log(this.color)
}

box.myApply(colors, [200, 300])   // 200, 300, red
box.myApply(null, [200, 300])     // 200, 300, blue
```

# 手写 bind

bind 方法会创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

```typescript
Function.prototype.myBind = function (context) {
	if (typeof this !== "function") {
    throw new Error("Error");
  }

  let self = this;
  let args = [...arguments].slice(1);
  
  let newFunc = function () {}
  let resultFunc = function () {
	  // 这里是调用时 resultFunc 的arguments
	  const bindArgs = [...arguments]
	  // 当作为构造函数时，this 指向实例，
	  // 此时结果为 true，将绑定函数的 this 指向该实例，
	  // 可以让实例获得来自绑定函数的值
	  
    // 当作为普通函数时，this 指向 window，
    // 此时结果为 false，将绑定函数的 this 指向 context
    return self.apply(this instanceof newFunc? 
    this : 
    context, 
    args.concat(bindArgs));
  }
  // 修改返回函数的 prototype 为绑定函数的 prototype，
  // 实例就可以继承绑定函数的原型中的值
  newFunc.prototype = self.prototype;
  resultFunc.prototype = new newFunc();
  
  return resultFunc
}

let colors = {
  color: 'red'
}

function box(width, height) {
  this.length = 20
  console.log(width)
  console.log(height)
  console.log(this.color)
}
box.prototype.price = 666

let mybox = box.myBind(colors, 200)
mybox(300)  // 200, 300, red mybox作为普通函数，this指向了colors
let yourBox = new mybox(300) // 200, 300, undefined
console.log(yourBox.length, yourBox.price) // 20 ,600 mybox作为构造函数，this指向了实例yourBox
```

# `instanceof`

`instanceof`就是判断构造函数的 `prototype`属性是否出现在实例的原型链上。

```typescript
function myInstanceof(left, right) {
	const prototype = right.prototype
	left = left.__proto__
	// 查找原型链
	while (left) {
		if (prototype === left) return true
		left = left.__proto__
	}
	
	return false
}

function Box(width) {
  this.width = width;
}
var bigBox = new Box(666);
console.log(myInstanceof(bigBox, Box));
```

# 继承

## 原型链继承

```javascript
function Parent() {
	this.color = ['black', 'white']	
}

Parent.prototype.getColor = function() {
	return this.color
}

function Child() {}
Child.prototype = new Parent()
```

e.g.

```javascript
function Animal() {
    this.colors = ['black', 'white']
}
Animal.prototype.getColor = function() {
    return this.colors
}
function Dog() {}
Dog.prototype = new Animal()

let dog1 = new Dog()
dog1.colors.push('brown')
let dog2 = new Dog()
console.log(dog2.colors)  // ['black', 'white', 'brown']
```

原型链继承存在的问题：

- 问题1：原型中包含的引用类型属性将被所有实例共享；
- 问题2：子类在实例化的时候不能给父类构造函数传参；

## **借用构造函数实现继承**

```javascript
function Parent() {
	this.color = ['black', 'white']	
}

function Child(color) {
	Parent.call(this, color)
}

Child.prototype = new Parent()
```

e.g.

```javascript
function Animal(name) {
    this.name = name
    this.getName = function() {
        return this.name
    }
}
function Dog(name) {
    Animal.call(this, name)
}
Dog.prototype =  new Animal()
```

借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。

## **组合继承**

组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。

```javascript
function Parent() {
	this.color = ['black', 'white']	
}

function Child(color) {
	Parent.call(this, color)
}

Child.prototype = new Parent()
Child.prototype.constructor = Child
```

e.g.

```javascript
function Animal(name) {
    this.name = name
    this.colors = ['black', 'white']
}
Animal.prototype.getName = function() {
    return this.name
}
function Dog(name, age) {
    Animal.call(this, name)
    this.age = age
}
Dog.prototype = new Animal()
Dog.prototype.constructor = Dog

let dog1 = new Dog('奶昔', 2)
dog1.colors.push('brown')
let dog2 = new Dog('哈赤', 1)
console.log(dog2) 
// { name: "哈赤", colors: ["black", "white"], age: 1 }
```

## **寄生式组合继承**

组合继承已经相对完善了，但还是存在问题，它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。

所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。

寄生式组合继承写法上和组合继承基本类似，区别是如下这里：

```javascript
function object(o) {
	function F() {}
	F.prototype = o
	return new F()
}

function inherit(child, parent) {
	 let prototype = object(parent.prototype)
	 prototype.constructor = child
	 child.prototype = prototype
}

function Parent() {
	this.color = ['black', 'white']	
}

function Child(color) {
	Parent.call(this, color)
}

Child.prototype =  Object.create(Parent.prototype)
Child.prototype.constructor = Child
```

## class 继承

```javascript
class Animal {
    constructor(name) {
        this.name = name
    } 
    getName() {
        return this.name
    }
}
class Dog extends Animal {
    constructor(name, age) {
		    // 通过超类调用父类构造函数
        super(name)
        this.age = age
    }
}
```

# `new`

```typescript
function myNew(Obj, ...args) {
	let obj = Object.create(Obj.prototype)
	let ret = Obj.apply(obj, args)
	if (ret &&(typeof ret === 'object' || typeof ret === 'function')) {
		return ret
	}
	return obj
}

function Foo(name, age) {
   this.name = name;
   this.age = age
}

let tom = new Foo('tom', 18)  // {name: "tom", age: 18}
let jim = myNew(Foo, 'jim', 15) // {name: "jim", age: 15}
```

# `Object.create`

`Object.create()`方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。

```typescript
Object.myCreate = function (obj, properties) {
  let F = function() {}
  F.prototype = obj
  if (properties) {
     Object.defineProperties(F, properties)
  }
  return new F()
}

let box = {
  color: 'blue',
  width: 200,
  height: 300
}
let obj = Object.myCreate(box) // {}
obj.__proto__ === box // true
```

# `Object.assign`

用于将一个或多个源对象（`source`）的可枚举属性复制到目标对象（`target`）中。

```typescript
Object.myAssign = function(target, ...source) {
	if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object')
  }
  
  let ret = Object(target)
  source.forEach((obj) => {
	  if (obj !== null) {
		  for (let key in obj) {
			  if (obj.hasOwnProperty) {
				  ret[key] = obj[key]
			  }
		  }
	  }
  })
  return ret
}

let box = {
  color: 'blue',
  width: 200,
  height: 300
}
let obj1 = Object.myAssign({}, box) // {color: "blue", width: 200, height: 300}
let obj2 = Object.myAssign({color: 'red'}, box) // {color: "blue", width: 200, height: 300}
```

# 手写深拷贝

实现一个深拷贝函数，支持拷贝常见的数据类型，例如对象、数组、函数、正则、日期等，并且能够正常处理循环引用。

```typescript
function deepClone(obj, hashMap = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);

  // 检查对象是否已经在哈希表中，避免循环引用
  if (hashMap.has(obj)) return hashMap.get(obj);

  let copy;

  // 处理数组
  if (Array.isArray(obj)) {
    copy = [];
    hashMap.set(obj, copy);
    obj.forEach((item) => copy.push(deepClone(item, hashMap)));
    return copy;
  } else {
    // 处理对象
    copy = {};
    hashMap.set(obj, copy);
    Object.entries(obj).forEach(
      ([key, value]) => (copy[key] = deepClone(value, hashMap))
    );
    return copy;
  }
}

```

# Curry 化

将使用多个参数的函数转换成一系列使用一个参数的函数。

```javascript
function curry(fn) {
    let judge = (...args) => {
        if (args.length == fn.length) return fn(...args)
        return (...arg) => judge(...args, ...arg)
    }
    return judge
}

```

变体：只有当传入参数长度为 0 时（即没有传入参数）才执行函数

```javascript
function curry(fn) {
    let args = [];
    let judge = (...newArgs) => {
        if (newArgs.length === 0) {
            const result = fn(...args);
            // 这里需要注意闭包，由于闭包内部涉及的变量不会被主动回收，如果不手动清空则会导致参数的累积
            args = [];
            return result;
        }
        args = [...args, ...newArgs];
        return judge;
    };
    return judge;
}
function add(a, b, c) {
    return a + b + c;
}
let addCurry = curry(add);
console.log(addCurry(1)(2)(3)());
console.log(addCurry(1, 2)(3)());
console.log(addCurry(1)(2)());
console.log(addCurry());
console.log(addCurry(1));

```

> 这里就可以用来面试时说明闭包 / 内存泄露的相关问题了
> 

# 手写 ajax

```javascript
function ajax(url) {
  return new Promise((res, rej) => {
    const xhr = XMLHttpRequest ? 
    new XMLHttpRequest() : 
    new ActiveXObject('Microsoft.XMLHTTP');

    xhr.open('GET', url, false)
    xhr.setRequestHeader('Accept', 'application/json')
    xhr.onreadystatechange = function() {
      if (xhr.readyState !== 4) return;
      if (xhr.status === 200 || xhr.status === 304) {
        res(xhr.responseText)
      } else {
        rej(new Error(xhr.responseText))
      }
    }

    xhr.send()

  })
}
```

# 手写防抖函数

实现一个防抖函数：**事件触发后等待一段时间**再执行回调函数，如果在等待期间内再次触发了同一事件，则重新计时，以避免回调函数的多次执行。

```javascript
function decounce(fn, delay) {
  let timer
  return (...args) => {
    let context = this
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => fn.apply(context, args), delay || 1000)
  }
}
```

**应用场景**

- 输入框展示搜索建议：当用户在输入框中连续输入时，只在用户停止输入后发送请求。
- 窗口大小变化（`resize`）事件：当用户调整窗口大小时，只在停止调整后执行布局计算，避免页面抖动。

# 手写节流函数

**在一定时间内，事件多次触发只执行一次回调函数**。不论事件触发多频繁，都会按照固定的时间间隔执行。

```javascript
function throttle(fn, interval) {
	let isThrottle = false
	
	return (...args) => {
		if (!isThrottle) {
			isThrottle = true;
			fn.apply(this, args)
			setTimeout(() => isThrottle = false, interval)
		}
	}
}
```

**应用场景**

- 图片滚动加载：页面滚动时，不断执行图片加载函数。（不使用防抖是因为不可能等到用户停止滚动才加载图片吧！）
- 拖拽（`touchmove`）事件：拖拽元素时，我们可能需要在拖拽过程中不断计算元素位置，但不希望计算过于频繁。

# **字符串模板**

```javascript
function render(template, data) {
  const reg = /{{(\w+)}}/
  if (reg.test(template)) {
    const name = reg.exec(template)[1]
    console.log(name)
    template = template.replace(reg, data[name])
    // 递归调用
    return render(template, data)
  }
  return template
}

let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';
let person = {
    name: '布兰',
    age: 12
}

console.log(render(template, person)); // 我是布兰，年龄12，性别undefined)
```

# 图片懒加载

```javascript
const imgList = [...document.querySelectorAll('img')]
const length = imgList.length
const imgLazyLoad = (function() {
  let count = 0
  const loadedImgList = []
  imgList.forEach((img, index) => {
    const rect = getBoundingClientRect()
    // 进入视窗
    if (rect.top < window.innerHeight) {
      img.src = img.dataset.src
      loadedImgList.push(index)
      count++
      // 移除监听
      if (count === length) {
        document.removeEventListener('scroll', imgLazyLoad)
      }
    }
  })
  // 排除加载完的图片
  imgList = imgList.filter((img, index) => !loadedImgList.includes(index))
})
// 这里最好加上防抖处理
document.addEventListener('scroll', imgLazyLoad)
```

# 事件总线

```javascript
class EventEmitter {
  constructor() {
    this.cache = new Map()
  }
  // 注册
  on(name, fn) {
    if (this.cache.has(name)) {
      const tasks = this.cache.get(name)
      tasks.push(fn)
      this.cache.set(name, tasks)
    } else {
      this.cache.set(name, [fn])
    }
  }
  // 注销
  off(name, fn) {
    const tasks = this.cache.get(name)
    if (tasks && tasks.length) {
      const index = tasks.findIndex(f => f === fn)
      if (index >= 0) {
        tasks.splice(index, 1)
      }
    }
  }
  // 触发
  emit(name, once = false, ...args) {
    if (this.cache.has(name)) {
      const tasks = this.cache.get(name)
      for (const task of tasks) {
        task(...args)
      }
      if (once) {
        delete this.cache.get(name)
      }
    }
  }

}

// 测试
let eventBus = new EventEmitter()
let fn1 = function(name, age) {
	console.log(`${name} ${age}`)
}
let fn2 = function(name, age) {
	console.log(`hello, ${name} ${age}`)
}
eventBus.on('aaa', fn1)
eventBus.on('aaa', fn2)
eventBus.emit('aaa', false, '布兰', 12)
// '布兰 12'
// 'hello, 布兰 12'

```

# URL 解析

```javascript
let url = 'https://www.baidu.com/s?id=123&name=why&phone=13876769797';
function getQueryString(name) {
  let strs = '';
  let index = url.indexOf('?');
  if(index!=-1) {
    strs = url.substring(index+1).split('&');
  }
  for (let index = 0; index < strs.length; index++) {
    let splitItem = strs[index].split('=');
    if(splitItem[0]==name) {
      return splitItem[1];
    }
  }
};

console.log(getQueryString('name')); 
```

# 分时函数

分时函数是一种任务调度策略，其核心思想是将大任务拆分成多个小任务，并在不同时间片内执行，以提高系统的流畅性和性能。

```javascript
function timeChunk(arr, fn, count, interval) {
  let timer = null
  let data = null
  function start() {
    for (let i = 0; i < Math.min(count || 1, arr.length); i++) {
      data = arr.shift()
      fn(data)
    }
  }

  return () => {
    timer = setInterval(() => {
      if (arr.length === 0) {
        clearInterval(timer)
        timer = null
        return
      }
      start();
    }, interval || 200)
  }
}

let arr = []
for (let i = 1; i <= 1000; i++) {
  arr.push(i)
}

const test = timeChunk(arr, (i) => console.log(i), 10, 1000)
test()
```

# **sleep**

```javascript
function sleep(time) {
	return Promise((resolve) => setTimeout(resolve, time))
}
```

# flatten

```javascript
function flatten(arr) {
  const newArr = []
  arr.forEach(item => {
    if (Array.isArray(item)) {
      newArr.push(...flatten(item))
    } else {
      newArr.push(item)
    }
  });

  return newArr
}

console.log(flatten([3,[4,8,[9,1],3],[6,8],[2,10],5,7]))
```

# LazyMan

```javascript
function Lazyman(name) {
    this.name = name
    this.queue = []
    this.queue.push(() => {
        console.log(`Hi, this is ${name}`)
        this.next()
    })
    setTimeout(() => this.next())
}

Lazyman.prototype.next = function () {
    let fn = this.queue.shift()
    fn && fn()
}

Lazyman.prototype.eat = function(name) {
    this.queue.push(() => {
        console.log('Eat ' + name)
        this.next()
    })
    // 支持链式调用
    return this
}

Lazyman.prototype.sleep = function(time) {
    this.queue.push(() => {
        setTimeout(() => {
            console.log("Wake up after " + time + "s!");
            this.next()
        }, time * 1000)
    })
    // 支持链式调用
    return this
}

Lazyman.prototype.sleepFirst = function(time){
    this.queue.unshift(() =>{
        setTimeout(() => {
            console.log("Wake up after " + time + "s!");
            this.next()
        }, time * 1000)
    })
    return this;
}

function lazyman(name) {
    return new Lazyman(name)
}

const lazy = lazyman('破酥')
lazy.eat('test').sleep(100)
lazy.sleep(1000)
```

# 金钱千分位

```javascript
function formatRegExp1(number) {
    var pattern = /(?=(\B\d{3})+\.)/g
    return number.toFixed(2).toString().replace(pattern, ',')
}

function formatRegExp2(number) {
    var pattern = /(\d)(?=(?:\d{3})+\.)/g
    return number.toFixed(2).toString().replace(pattern, '$1,')
}

function format(number) {
    number = number.toFixed(2).toString()
    var dotIndex = number.indexOf('.')
    var part = number.substring(0, dotIndex)
    var flag = 0
    var result = ''
    for (var i = part.length - 1; i >= 0; i--) {
        result = part[i] + result
        if (i !== 0 && ++flag === 3) {
            result = ',' + result
            flag = 0
        }
    }
    return result + number.substring(dotIndex)
}
```

# `toFixed()`

```javascript
function toFixed(num, d) {
  num *= Math.pow(10, d);  // 步骤1：将 num 放大 d 位
  num = Math.round(num);   // 步骤2：四舍五入到最接近的整数
  return num / Math.pow(10, d);  // 步骤3：将 num 缩小回去，恢复小数点的位置
}
```

# toHump / toLine

```typescript
/**
 * 数据对象key 驼峰下划线相互转化
 * @param {Object} data - 原始对象 支持-数组、key-value对象、字符串
 * @param {String} type hump-转驼峰 toLine-转下划线
 */
function formatHumpLineTransfer (data, type = 'hump') {
  let hump = ''
  // 转换对象中的每一个键值为驼峰的递归
  const formatTransferKey = (data) => {
    if (data instanceof Array) {
      data.forEach(item => formatTransferKey(item))
    } else if (data instanceof Object) {
      for (let key in data) {
        hump = type === 'hump' ? this.formatToHump(key) : this.formatToLine(key)
        data[hump] = data[key]
        // 删除未转化的值，只留下转化后的
        if (key !== hump) {
          delete data[key]
        }
        if (data[hump] instanceof Object) {
          formatTransferKey(data[hump])
        }
      }
    } else if (typeof data === 'string') {
      data = type === 'hump' ? this.formatToHump(data) : this.formatToLine(data)
    }
  }
  formatTransferKey(data)
  return data
}

/**
 * 字符串下划线转驼峰
 * @param {String} value 需要转换的值
 */
function formatToHump(value) {
  return value.replace(/\_(\w)/g, (_, letter) => letter.toUpperCase())
}

/**
 * 字符串驼峰转下划线
 * @param {String} value 
 */
function formatToLine(value) {
  return value.replace(/([A-Z])/g,"_$1").toLowerCase()
}
```

# 超时 promise

```typescript
function withTimeout(promise, timeout) {
	const timeoutPromise = new Promise((_, reject) => {
		setTimeout(() => reject(new Error("请求超时")), timeout);
	});
	
	return Promise.race([promise, timeoutPromise]);
}
// 示例：请求任务超时处理
const fetchData = new Promise((resolve) => {
	setTimeout(() => resolve("数据加载成功"), 3000); // 模拟 3 秒后完成
});

withTimeout(fetchData, 2000)
	.then((data) => console.log(data))
	.catch((error) => console.error(error.message));
```

# 版本号比较

```javascript
function compareVersion(v1, v2) {
    const arr1 = v1.split('.').map(Number);
    const arr2 = v2.split('.').map(Number);
    const len = Math.max(arr1.length, arr2.length);

    for (let i = 0; i < len; i++) {
        const num1 = arr1[i] || 0; // 不存在时补 0
        const num2 = arr2[i] || 0;
        if (num1 > num2) return 1;  // v1 > v2
        if (num1 < num2) return -1; // v1 < v2
    }
    return 0; // v1 == v2
}

// 测试
console.log(compareVersion("1.2.10", "1.2.3")); // 1
console.log(compareVersion("1.0", "1.0.0"));    // 0
console.log(compareVersion("1.0.1", "1.1"));    // -1

```

# 鹅厂文化衫

企鹅厂活动发文化衫，文化衫有很多种，企鹅们都穿文化衫。采访中，企鹅会说还有多少企鹅跟他穿一种文化衫。有些企鹅没被采访到，将这些回答放在answers数组里，返回活动中企鹅的最少数

![image.png](attachment:7b3aa285-4b95-4dc2-aca8-9670e073a759:image.png)

![image.png](attachment:78ad6f0c-96ba-4d76-adb7-ce5052c85e63:image.png)

```typescript
/**
 * 企鹅厂活动发文化衫问题
 * 
 * 题目描述：
 * 企鹅厂活动发文化衫，文化衫有很多种，企鹅们都穿文化衫。
 * 采访中，企鹅会说还有多少企鹅跟他穿一种文化衫。
 * 有些企鹅没被采访到，将这些回答放在answers数组里，返回活动中企鹅的最少数量。
 * 
 * 算法思路：
 * 1. 如果一个企鹅说有x个企鹅跟他穿同样的文化衫，那么这种文化衫至少有(x+1)个企鹅穿
 * 2. 如果有c个企鹅都说有x个企鹅跟他们穿同样的文化衫，那么这种文化衫的企鹅数量为：
 *    ceil(c / (x+1)) * (x+1)
 * 3. 遍历所有回答，按相同回答分组计算最少企鹅数
 */

function minPeople(answers) {
    if (answers.length === 0) return 0;

    // 先排序，让说同一种数量衣服的企鹅穿同一种衣服，这时候就可以按相同回答分组计算最少企鹅数
    answers.sort((a, b) => a - b);
    
    let currentAnswer = answers[0];  // 当前处理的回答
    let count = 1;                   // 说同样回答的企鹅数量
    let totalPenguins = 0;          // 总企鹅数量
    
    for (let i = 1; i < answers.length; i++) {
        if (currentAnswer !== answers[i]) {
            // 遇到不同的回答，计算当前回答对应的最少企鹅数
            // 如果有count个企鹅说有currentAnswer个企鹅跟他们穿同样的文化衫
            // 那么这种文化衫至少需要 ceil(count / (currentAnswer + 1)) * (currentAnswer + 1) 个企鹅
            const groupSize = currentAnswer + 1;  // 每组文化衫的企鹅数（包括被采访的企鹅）
            const minGroups = Math.ceil(count / groupSize);  // 最少需要的组数
            totalPenguins += minGroups * groupSize;
            
            // 更新到新的回答
            currentAnswer = answers[i];
            count = 1;
        } else {
            count++;
        }
    }
    
    // 处理最后一组回答
    const groupSize = currentAnswer + 1;
    const minGroups = Math.ceil(count / groupSize);
    totalPenguins += minGroups * groupSize;
    
    return totalPenguins;
}

console.log("1,1,2,1,3,1的最少企鹅数为:", minPeople([1,1,2,1,3,1]));

```

# 赛马问题

给定 25 匹马与 5 条赛道，一个赛道只能容纳一匹马，每轮比赛只能得到 5 匹马之间的快慢程度，而不是速度，求决胜 1，2，3 名至少多少轮。

给定 25 匹马与 5 条赛道，一个赛道只能容纳一匹马，每轮比赛只能得到 5 匹马之间的快慢程度，而不是速度，求决胜 1，2，3 名至少多少轮。

25→3 : 7

25→5: 8-9

64→4：10

# lodash.get

```typescript
function get(obj, path, defaultValue) {
    // 将路径转换为数组
    const keys = path.split('.').map(key => {
        // 处理数组路径，例如 'a[0]' 转为 'a' 和 0
        const match = key.match(/^(\w+)\[(\d+)\]$/);
        if (match) {
            return [match[1], parseInt(match[2], 10)];
        }
        return key;
    }).flat();

    // 遍历路径数组，逐层获取对象属性
    let result = obj;
    for (let key of keys) {
        result = result ? result[key] : undefined;
        if (result === undefined) break;
    }

    // 如果结果为 undefined，返回默认值
    return result === undefined ? defaultValue : result;
}

// 示例对象
const obj = { a: [{ b: { c: 3 } }] };

// 测试用例
console.log(get(obj, 'a[0].b.c', 'default')); // 输出: 3
console.log(get(obj, 'a[0].b.d', 'default')); // 输出: default

```

# IP 地址与整数之间的转换

```javascript
/**
 * 将IP地址字符串转换为无符号整数
 * 
 * 转换原理：
 * 1. 将IP地址按'.'分割成4个数字
 * 2. 使用位运算将4个数字组合成32位整数
 * 3. 每次左移8位相当于乘以256，然后与下一个数字进行或运算
 * 
 * 位运算详解：
 * - res << 8: 将当前结果左移8位，为下一个字节腾出空间
 * - | ipList[i]: 使用或运算将当前字节的值填入最低8位
 * - >>> 0: 无符号右移0位，确保结果为无符号32位整数
 * 
 * @param {string} ip IP地址字符串，格式如 "192.168.1.1"
 * @returns {number} 对应的无符号整数（0 到 4294967295）
 * 
 * @example
 * ipToInt("192.168.1.1") // 返回 3232235777
 * ipToInt("0.0.0.0")     // 返回 0
 * ipToInt("255.255.255.255") // 返回 4294967295
 */
function ipToInt(ip) { 
    // 将IP地址按'.'分割，并将每个字符串转换为数字
    // +ip 是将字符串转换为数字的简洁写法，等同于 parseInt(ip, 10)
    const ipList = ip.split('.').map(ip => +ip);
    
    const n = ipList.length; // 通常为4，表示IP地址的4个段
    let res = 0; // 初始化结果为0
    
    // 遍历IP地址的每个段，从高位到低位进行组合
    for (let i = 0; i < n; i++) {
        // 核心算法：左移8位 + 或运算
        // res << 8: 将之前的结果左移8位，为当前字节腾出空间
        // | ipList[i]: 将当前字节的值填入最低8位
        res = (res << 8) | ipList[i];
    }
    
    // 使用无符号右移确保返回无符号32位整数
    // JavaScript中的数字默认是有符号的，>>> 0可以转换为无符号整数
    return res >>> 0;
}

/**
 * 将无符号整数转换为IP地址字符串
 * 
 * 转换原理：
 * 1. 从32位整数的低位开始，每次提取8位（1字节）
 * 2. 使用位运算提取每个字节的值（0-255）
 * 3. 将提取的4个字节反转后用'.'连接成IP地址
 * 
 * 位运算详解：
 * - num & 255: 与运算提取最低8位，255的二进制是11111111
 * - num >>> 8: 无符号右移8位，丢弃已处理的最低8位
 * 
 * @param {number} num 无符号整数（0 到 4294967295）
 * @returns {string} 对应的IP地址字符串，格式如 "192.168.1.1"
 * 
 * @example
 * intToIp(3232235777) // 返回 "192.168.1.1"
 * intToIp(0)          // 返回 "0.0.0.0"
 * intToIp(4294967295) // 返回 "255.255.255.255"
 */
function intToIp(num) {
    const ipList = []; // 存储IP地址的4个段
    
    // 从低位到高位提取4个字节
    for (let i = 0; i < 4; i++) {
        // 使用位与运算提取最低8位
        // 255的二进制是11111111，与任何数进行&运算都只保留最低8位
        const seg = (num & 255).toString();
        ipList.push(seg);
        
        // 无符号右移8位，处理下一个字节
        // 使用>>>而不是>>确保是无符号右移，避免符号位扩展
        num = num >>> 8;
    }
    
    // 由于我们是从低位到高位提取的，需要反转数组
    // 这样IP地址的顺序就是从高位到低位：a.b.c.d
    ipList.reverse();
    
    // 将4个数字用'.'连接成IP地址字符串
    let res = "";
    for (let i = 0; i < 4; i++) {
        if (i === 3) {
            // 最后一个数字后面不加'.'
            res += ipList[i];
        } else {
            // 前三个数字后面都要加'.'
            res += ipList[i] + '.';
        }
    }
    
    return res;
}
```

# rand66536 生成 rand300000

有一个rand()支持随机生成[0~65535]的整数，如何做到支持随机生成1~300000的整数。

```javascript
function randExtended() {
    const targetRange = 300000; // 目标范围：1~300000
    const maxRand = 65536; // rand()的最大值+1
    const totalRange = maxRand * maxRand; // 两个rand()组合的总范围：4294967296
    
    // 计算最大可接受的值，确保均匀分布
    // k是最大整数，使得targetRange * k <= totalRange
    const k = Math.floor(totalRange / targetRange);
    const maxAcceptable = targetRange * k - 1; // 4294800000 - 1
    
    let x;
    do {
        // 使用两个rand()构造更大范围的随机数
        // 相当于把两个16位数组合成一个32位数
        x = rand() * maxRand + rand(); // 生成0~4294967295
    } while (x > maxAcceptable); // 拒绝采样，确保均匀分布
    
    // 映射到目标范围[1, 300000]
    return (x % targetRange) + 1;
}
```
